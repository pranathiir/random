#include<windows.h>
#include<iostream>
#include<GL/glut.h>
#include<math.h>
using namespace std;

#define SCREEN_HEIGHT 480

int count = 0;
int pointsCount = 0;
int countRect = 0;
int countCircle = 0;
string shape="";

struct Point
{
    GLint x;
    GLint y;
};

Point coordinates[500];

struct GLColor
{
GLfloat red;
GLfloat green;
GLfloat blue;
};

void init()
{
    glClearColor(0, 0, 0, 1);
    glPointSize(4.0f);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0, 640, 0, 480);
}
void display(void)
{
    glColor3f(0.4, 0.4, 0.8);
	///axis
    glBegin(GL_LINES);
        glVertex2f(320, 0);
        glVertex2f(320, 480);
        glVertex2f(0, 240);
        glVertex2f(640, 240);
    glEnd();
    glFlush();
}

void mouse_handling(int button, int state, int x, int y)
{
    if(button==GLUT_LEFT && state==GLUT_DOWN)
    {
        y = SCREEN_HEIGHT-y;
        coordinates[count].x = x-320;
        coordinates[count].y = y-240;
        count++;
    }
}

void drawCircle(Point center, Point onCircle)
{
    float radius = sqrt(pow(center.x-onCircle.x, 2) + pow(center.y-onCircle.y, 2));
    int p[100];
    Point points[100];
    points[0].x = 0;
    points[0].y = radius;
    p[0] = 1-radius;
    int i = 1;
    while(points[i-1].x < points[i-1].y)
    {
        if(p[i-1]<0)
        {
            points[i].x = points[i-1].x+1;
            points[i].y = points[i-1].y;
            p[i] = p[i-1]+2*points[i].x+1;
            i++;

        }
        else
        {
            points[i].x = points[i-1].x+1;
            points[i].y = points[i-1].y-1;
            p[i] = p[i-1]+2*points[i].x+1-2*points[i].y;
            i++;
        }
    }
    center.x += 320;
    center.y += 240;
    glBegin(GL_POINTS);
    for(int j=0; j<=i; j++)
    {
            glColor3f(0, 0.3, 0.6);
            glVertex2f(points[j].x+center.x, points[j].y+center.y);
            glVertex2f(points[j].y+center.x, points[j].x+center.y);
            glColor3f(0.3, 0, 0.6);
            glVertex2f(points[j].y+center.x, -points[j].x+center.y);
            glVertex2f(points[j].x+center.x, -points[j].y+center.y);
            glColor3f(0.3, 0.6, 0);
            glVertex2f(-points[j].y+center.x, points[j].x+center.y);
            glVertex2f(-points[j].x+center.x, points[j].y+center.y);
            glColor3f(0.6,  0.3, 0);
            glVertex2f(-points[j].x+center.x, -points[j].y+center.y);
            glVertex2f(-points[j].y+center.x, -points[j].x+center.y);
    }
    glEnd();
    glFlush();
}
void drawRect(Point lowerLeft,Point upperRight)
{

    glBegin(GL_QUADS);
        glVertex2f(lowerLeft.x+320,lowerLeft.y+240);
        glVertex2f(upperRight.x+320,lowerLeft.y+240);
        glVertex2f(upperRight.x+320,upperRight.y+240);
        glVertex2f(lowerLeft.x+320,upperRight.y+240);
    glEnd();
    glFlush();
}

void drawRectRotation(Point lowerLeft, Point lowerRight, Point upperRight, Point upperLeft)
{
    glColor3f(1, 0, 1);
    glBegin(GL_QUADS);
        glVertex2f(lowerLeft.x,lowerLeft.y);
        glVertex2f(lowerRight.x,lowerRight.y);
        glVertex2f(upperRight.x,upperRight.y);
        glVertex2f(upperLeft.x,upperLeft.y);
    glEnd();
    glFlush();
}


void translation(Point p1,Point p2)
{
    Point translate;
    translate.x=100;
    translate.y=100;
    if(shape=="rectangle")
    {
        Point translateLowerLeft;
        translateLowerLeft.x = p1.x+translate.x;
        translateLowerLeft.y = p1.y+translate.y;

        Point translateUpperRight;
        translateUpperRight.x = p2.x+translate.x;
        translateUpperRight.y = p2.y+translate.y;
        glColor3f(1, 1, 0);
        drawRect(translateLowerLeft, translateUpperRight);
    }
    if(shape=="circle")
    {
        Point transCenter;
        transCenter.x=p1.x+translate.x;
        transCenter.y=p1.y+translate.y;

        Point transOnCircle;
        transOnCircle.x=p2.x+translate.x;
        transOnCircle.y=p2.y+translate.y;
        drawCircle(transCenter,transOnCircle);
    }

}

void rotation(Point p1,Point p2)
{
    float angle,cosVal,sinVal;
    string direction;
    angle=45;
    direction="counter-clockwise";
    if(direction=="counter-clockwise")
    {
        cosVal=cos(angle);
        sinVal=sin(angle);
    }
    else if(direction=="clockwise")
    {
        cosVal=cos(-angle);
        sinVal=sin(-angle);
    }
    Point pivot;
    pivot.x=320;
    pivot.y=240;
    if(shape=="rectangle")
    {
        Point lowerLeft;
        lowerLeft.x=((p1.x+320)*cosVal)-((p1.y+240)*sinVal)+((1-cosVal)*pivot.x)+(sinVal*pivot.y);
        lowerLeft.y=((p1.x+320)*sinVal)+((p1.y+240)*cosVal)+((1-cosVal)*pivot.y)-(sinVal*pivot.x);

        Point upperRight;
        upperRight.x=((p2.x+320)*cosVal)-((p2.y+240)*sinVal)+((1-cosVal)*pivot.x)+(sinVal*pivot.y);
        upperRight.y=((p2.x+320)*sinVal)+((p2.y+240)*cosVal)+((1-cosVal)*pivot.y)-(sinVal*pivot.x);

        Point lowerRight;
        lowerRight.x=((p1.x+320)*cosVal)-((p2.y+240)*sinVal)+((1-cosVal)*pivot.x)+(sinVal*pivot.y);
        lowerRight.y=((p1.x+320)*sinVal)+((p2.y+240)*cosVal)+((1-cosVal)*pivot.y)-(sinVal*pivot.x);

        Point upperLeft;
        upperLeft.x=((p2.x+320)*cosVal)-((p1.y+240)*sinVal)+((1-cosVal)*pivot.x)+(sinVal*pivot.y);
        upperLeft.y=((p2.x+320)*sinVal)+((p1.y+240)*cosVal)+((1-cosVal)*pivot.y)-(sinVal*pivot.x);


        drawRectRotation(lowerLeft,lowerRight,upperRight,upperLeft);
    }
}

void scaling(Point p1,Point p2)
{
    float scaleX=2, scaleY=2;
    Point pivot;
    pivot.x=((p2.x-p1.x))/2 + p1.x ;
    pivot.y=((p2.y-p1.y))/2 + p1.y ;
    if(shape=="rectangle")
    {
        Point lowerLeft;
        lowerLeft.x=p1.x*scaleX+pivot.x*(1-scaleX);
        lowerLeft.y=p1.y*scaleY+pivot.y*(1-scaleY);

        Point upperRight;
        upperRight.x=p2.x*scaleX+pivot.x*(1-scaleX);
        upperRight.y=p2.y*scaleY+pivot.y*(1-scaleY);
        glColor3f(0.5,0.5,0);
        drawRect(lowerLeft,upperRight);
    }
    if(shape=="circle")
    {
        Point transOnCircle;
        transOnCircle.x=p2.x*scaleX+pivot.x*(1-scaleX);
        transOnCircle.y=p2.y*scaleY+pivot.y*(1-scaleY);

        drawCircle(p1,transOnCircle);
    }
}

void reflection(Point p1,Point p2)
{
    if(shape=="rectangle")
    {
        Point lowerLeft;
        lowerLeft.x=p1.y;
        lowerLeft.y=p1.x;

        Point upperRight;
        upperRight.x=p2.y;
        upperRight.y=p2.x;
        glColor3f(0,1,0);
        drawRect(lowerLeft,upperRight);

        lowerLeft.x=p1.x;
        lowerLeft.y=-p1.y;

        upperRight.x=p2.x;
        upperRight.y=-p2.y;
        glColor3f(1,0,0);
        drawRect(lowerLeft,upperRight);

        lowerLeft.x=-p1.x;
        lowerLeft.y=p1.y;

        upperRight.x=-p2.x;
        upperRight.y=p2.y;
        glColor3f(0,0,1);
        drawRect(lowerLeft,upperRight);

    }
}


void mainMenuHandler(int choice) {
    Point p1={coordinates[count-2].x,coordinates[count-2].y};
    Point p2={coordinates[count-1].x,coordinates[count-1].y};
    switch(choice) {
    case 1:
        translation(p1,p2);
        break;

    case 2:
        rotation(p1,p2);
        break;

    case 3:
        scaling(p1,p2);
        break;

    case 4:
        reflection(p1,p2);
        break;

    case 5:
        break;
    }
}

void mouse_handling_circle(int button,int state,int x,int y)
{
    if(button==GLUT_LEFT && state==GLUT_DOWN)
    {
        y=SCREEN_HEIGHT-y;
        coordinates[count].x=x-320;
        coordinates[count].y=y-240;
        count++;
        countCircle++;
        if(countCircle!=0 && countCircle==2)
        {
            Point p1={coordinates[count-2].x,coordinates[count-2].y};
            Point p2={coordinates[count-1].x,coordinates[count-1].y};
            drawCircle(p1,p2);
            countCircle=0;
        }
    }

}

void mouse_handling_rectangle(int button,int state,int x,int y)
{
    if(button==GLUT_LEFT && state==GLUT_DOWN)
    {
        y=SCREEN_HEIGHT-y;
        coordinates[count].x=x-320;
        coordinates[count].y=y-240;
        countRect++;
        count++;
        if(countRect!=0 and countRect==2)
        {
            Point p1={coordinates[count-2].x,coordinates[count-2].y};
            Point p2={coordinates[count-1].x,coordinates[count-1].y};
            glColor3f(0,1,1);
            drawRect(p1,p2);
            countRect=0;
        }
    }

}



void subMenuHandler(int choice) {
     switch(choice)
     {
        case 0:
            shape="circle";
            glutMouseFunc(mouse_handling_circle);
        break;

        case 1:
            shape="rectangle";
            glutMouseFunc(mouse_handling_rectangle);
        break;

    }

}

int main(int argc, char **argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);
    glutInitWindowPosition(200, 200);
    glutInitWindowSize(640, 480);
    glutCreateWindow("OpenGL");
    init();

    glutDisplayFunc(display);

    glutMouseFunc(mouse_handling);
    int subMenu = glutCreateMenu(subMenuHandler);
    glutAddMenuEntry("Circle", 0);
    glutAddMenuEntry("Rectangle", 1);
    glutCreateMenu(mainMenuHandler);
    glutAddSubMenu("Draw object", subMenu);
    glutAddMenuEntry("Translation", 1);
    glutAddMenuEntry("Rotation", 2);
    glutAddMenuEntry("Scaling", 3);
    glutAddMenuEntry("Reflection", 4);
    glutAddMenuEntry("Exit", 5);

    glutAttachMenu(GLUT_RIGHT_BUTTON);
    glutMainLoop();

    return 0;
}
