#runge kutta third
import numpy as np
def f(x, y):
    return x * y + x**2
x0 = 0
y0 = 1
h = 0.1
x_target = 0.4
num_steps_rk3 = int((0.4 - x0) / h)

def runge_kutta_third(x, y, h):
    k1 = h * f(x, y)
    k2 = h * f(x + h/2, y + k1/2)
    k3 = h * f(x + h, y - k1 + 2*k2)
    return y + (k1 + 4*k2 + k3) / 6

x_values_rk3 = [x0]
y_values_rk3 = [y0]

for _ in range(num_steps_rk3):
    x0 += h
    y0 = runge_kutta_third(x0, y0, h)
    x_values_rk3.append(x0)
    y_values_rk3.append(y0)

def milne_predictor_corrector(x_values, y_values, h):
    n = len(x_values)
    y_predicted = y_values[n - 1] + (4 * h / 3) * (
        2 * f(x_values[n - 1], y_values[n - 1]) -
        f(x_values[n - 2], y_values[n - 2]) +
        2 * f(x_values[n - 3], y_values[n - 3])
    )
    return y_predicted

def adams_bashforth(x_values, y_values, h):
    n = len(x_values)
    y_predicted = y_values[n - 1] + (h / 24) * (
        55 * f(x_values[n - 1], y_values[n - 1]) -
        59 * f(x_values[n - 2], y_values[n - 2]) +
        37 * f(x_values[n - 3], y_values[n - 3]) -
        9 * f(x_values[n - 4], y_values[n - 4])
    )
    return y_predicted

y_milne_predictor_corrector = milne_predictor_corrector(x_values_rk3, y_values_rk3, h)
y_adams_bashforth = adams_bashforth(x_values_rk3, y_values_rk3, h)

print("Values at x = 0.1, 0.2, 0.3 using Runge-Kutta third-order method:")
for x, y in zip(x_values_rk3, y_values_rk3):
    print(f"x = {x:.1f}, y = {y:.4f}")

print(f"y(0.4) by Milne's Predictor-Corrector: {y_milne_predictor_corrector:.4f}")
print(f"y(0.4) by Adams-Bashforth: {y_adams_bashforth:.4f}")
