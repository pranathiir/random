import numpy as np
from sympy import *

def inputfn():
    x = symbols('x')
    expr = input("function: ")
    expr = sympify(expr)
    a, b = map(int, (input("interval: ").split()))
    return expr, a, b

def bisectionMethod(ex, a, b):
    x = symbols('x')
    f1 = ex.subs(x, a)
    f2 = ex.subs(x, b)
    count = 0
    while(b-a >= 0.001):
        li = [f1, f2]
        sign = []
        si = np.sign(li)
        for i in si:
            if(i == -1):
                sign.append("negative")
            elif(i == 1):
                sign.append("positive")
            elif(i == 0):
                sign.append("zero")

        mid = (b+a)/2
        f3 = ex.subs(x, mid)
        print("iteration " + str(count) + " - ")
        print("a         b           mid      f(mid)  f(a)    f(b)")
        print(str("%.4f" % a) + "   " + str("%.4f" % b) + "   " + str("%.4f" % mid) + "    " + str("%.4f" % f3) + "    " + sign[0] + "    " + sign[1])
        if (f3 == 0):
            break
        if (f1*f3 < 0):
            b = mid
        else:
            a = mid
        count += 1
    print('\nroot: ')
    print("root's value: ", "%.4f" % mid)

ex, a, b = inputfn()
x = symbols('x')
f1 = ex.subs(x, a)
f2 = ex.subs(x, b)

if(f1 == 0):
    print('a whose value is ' + str(a) + ' is the root ')
elif(f2 == 0):
    print('b whose value is ' + str(b) + ' is the root ')
elif(f1 * f2 > 0):
    print("given interval doesnt contain root")
else :
    sol = bisectionMethod(ex, a, b)
    p1 = plot(ex)
